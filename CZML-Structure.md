# CZML 文档结构

CZML 是 [JSON](http://www.json.org) 的子集，这意味着有效的 CZML 文档也是有效的 JSON 文档。具体来说，一个 CZML 文档包含一个 JSON 数组，数组中的每个元素都是一个 CZML [[Packet]]。 CZML packet 描述场景中单个对象的图形属性，例如单个飞机。

_注意：我们在这些示例中使用 javascript 注释，然而 JSON 实际上不允许注释。_

```javascript
[
    // packet one
    {
        "id": "GroundControlStation"
        "position": { "cartographicDegrees": [-75.5, 40.0, 0.0] },
        "point": {
            "color": { "rgba": [0, 0, 255, 255] },
        }
    },
    // packet two
    {
        "id": "PredatorUAV",
        // ...
    }
]
```

每个 packet 都有一个 `id` 属性来标识它所描述的对象。 ID 不需要是 GUID，但它们确实需要唯一标识 CZML 源中的单个对象以及加载到同一范围内的任何其他 CZML 源。

如果没有指定 `id`，客户端会自动生成一个唯一的。 但是这会阻止以后的 packets 引用此对象，例如，向其添加更多数据。

除了 `id` 之外，[Packets](Packet) 包含零个或多个（但通常是一个或多个）属性，用于定义要绘制的与对象相关的图形项。 在上面的示例中，我们指定“GroundControlStation”对象包含固定位置： [WGS 84](http://en.wikipedia.org/wiki/World_Geodetic_System) 经度 -75.5 度，纬度 40.0 度，高度 0.0 米，并且在该位置绘制一个蓝色 [[Point]]。

CZML 定义了许多标准属性，包括用于将 [points](Point)、[billboards](Billboard)、[models](Model)、[lines](Polyline) 和其他图形添加到场景中的属性。[[Packet]] 页面上详细描述了可用属性，以及子属性和子类型的链接页面。在此页面上，我们主要关注数据的结构。例如，我们描述了如何指定一个属性，使其在两个不同的时间间隔内具有两个不同的值。

## Intervals 时间区间

在最一般的情况下，CZML 属性的值是一个 JSON 数组，其中数组中的每个元素都是一个对象字面量，定义了不同时间区间的属性值。数组中任何给定对象使用 `interval` 属性描述时间区间，属性的值为 [ISO8601 间隔](http://en.wikipedia.org/wiki/ISO_8601#Time_intervals) 字符串。

```javascript
{
    "id": "myObject",
    "someProperty": [
        {
            "interval": "2012-04-30T12:00:00Z/13:00:00Z",
            "number": 5
        },
        {
            "interval": "2012-04-30T13:00:00Z/14:00:00Z",
            "number": 6
        },
    ]
}
```

在这里，我们在两个时间区间内定义了 `someProperty` 属性，第一个从 UTC 中午到下午 1:00，属性的值为 5，另一个从 UTC 下午 1:00 到下午 2:00，其中的值 属性为 6。当跨越两个区间的边界时，该值将立即更改。我们使用 `number` 来表示值，因为这是一个数字类型的属性。一些属性，尤其是表示位置的属性，允许以多种格式指定值，例如笛卡尔 X、Y、Z 位置或制图经度、纬度、高度位置。每种类型的介绍页面列出了每种属性支持的数据类型，以及每个属性使用的值名称。

`interval` 属性是可选的。如果未指定，则假定时间区间跨越所有时间。指定多个时间区间或重叠的区间没有多大意义，但如果指定了，则 CZML 文件（或流）中较后定义的区间生效。

在属性只有一个区间的值的常见情况下，可以忽略区间列表数组。

```javascript
{
    "id": "myObject",
    "someProperty": {
        "interval": "2012-04-30T12:00:00Z/14:00:00Z",
        "number": 5
    }
}
```

与上例类似，如果 `interval` 属性跨越所有时间，则可以省略它。对于具有简单值的属性，如上图所示的 number 属性，以及始终具有单个值的属性，可以更简洁地给出该值：

```javascript
{
    "id": "myObject",
    "someProperty": 5
}
```

这种缩写对任何属性都有效，这些属性的值可以用简单的JSON数据类型之一表示：字符串、数字或布尔值。

## Composite Values 复合值

更复杂的复合值（如笛卡尔位置或颜色）使用 JSON 数组表示。对于笛卡尔位置，数组有三个元素，分别对应于位置的 X、Y 和 Z 分量。

```javascript
{
    "id": "myObject",
    "someComplexProperty": {
        "cartesian": [1.0, 2.0, 3.0]
    }
}
```

复合值必须始终在一个区间内指定（译注：需要使用一个时间区间对象），即使该区间是无限的，如图所示。如果允许将值 `[1.0,2.0,3.0]` 直接用作`complexProperty` 的值，则解析 CZML 时客户端需要查看数组的内容，以确定数组是时间间隔列表还是单个值。因此为了简单起见，我们不允许这样做。

## Sampled Property Values 采样属性值

到目前为止，我们已经讨论了如何始终为属性指定单个值，以及如何在不同的离散时间区间内为属性指定不同的值。某些属性还允许您指定时间标记的样本，客户端将对这些样本进行插值，以计算任何给定时间的属性值。时间值使用 [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) 字符串。

```javascript
{
    // ...
    "someInterpolatableProperty": {
        "cartesian": [
            "2012-04-30T12:00Z", 1.0, 2.0, 3.0,
            "2012-04-30T12:01Z", 4.0, 5.0, 6.0,
            "2012-04-30T12:02Z", 7.0, 8.0, 9.0
        ]
    }
}
```

在这里，我们指定的值是中午 `[1.0,2.0,3.0]`，一分钟后 `[4.0,5.0,6.0]`，再一分钟后 `[7.0,8.0,9.0]`。如果客户端的当前时钟为正午30秒，则该值将是 `[1.0,2.0,3.0]` 和 `[4.0,5.0,6.0]`之间的线性插值，即 `[2.5,3.5,4.5]`。

为了简洁起见，时间也可以从一个 `epoch` 开始以秒为单位指定。虽然这可能不如使用 ISO8601 字符串的精度高，但当样本跨度小于一天或偏移量为整数秒时，这通常就足够了。

```javascript
{
    // ...
    "someInterpolatableProperty": {
        "epoch": "2012-04-30T12:00Z",
        "cartesian": [
            0.0, 1.0, 2.0, 3.0,
            60.0, 4.0, 5.0, 6.0,
            120.0, 7.0, 8.0, 9.0
        ]
    }
}
```

最后，使用时间标记样本指定的属性具有一些额外的可选子属性，用于控制插值。

```javascript
{
    // ...
    "someInterpolatableProperty": {
        "epoch": "2012-04-30T12:00Z",
        "cartesian": [
            0.0, 1.0, 2.0, 3.0,
            60.0, 4.0, 5.0, 6.0,
            120.0, 7.0, 8.0, 9.0
        ],
        "interpolationAlgorithm": "LAGRANGE",
        "interpolationDegree": 5
    },
}
```

`interpolationAlgorithm` 指定了插值算法。有关可能的值，请参见下表。`interpolationDegree` 属性指定用于插值的多项式的阶数。如果未指定这些特性，则使用线性插值。有关插值的完整属性列表，请参见[[InterpolateProperty]]。

没有必要让每个样本的采样时间都在包含它的时间区间内，但样本不会在其时间区间之外使用。这有助于通过更高阶次的插值提供更好的精度。

## EventSource and Streaming 事件源和流

将整个 CZML 文档放在一个大的 JSON 数组中会使增量加载文档变得困难。现代 web 浏览器允许在流完成之前对其进行一些访问，但解析和解释不完整的数据需要缓慢而繁琐的字符串操作。为了促进高性能流式传输，CZML 也可以使用现代浏览器的 [server sent events](http://dev.w3.org/html5/eventsource/)（`EventSource`）API 进行流式传输。使用此 API 时，每个 CZML packet 作为单独的事件流式传输到客户端：

```javascript
event: czml
data: {
    // packet one
}

event: czml
data: {
    // packet two
}
```

当收到每个 packet 时，浏览器会触发一个事件，其中只包含该 packet 的数据。这使我们能够以优异的性能增量处理 CZML 数据。

到目前为止，我们可能已经暗示，单个对象是使用一个 packet 来表示的，该 packet 描述了与该对象相关的所有图形。但事实并非如此。一个 CZML 流或文档可以包含多个具有相同 `id` 的 packet，描述同一对象的不同方面。

事实上，在某些情况下，两个 packet 甚至可以描述同一个对象的相同属性。当在多个时间区间上定义属性时，或者当一个时间区间包含多个时间标记的样本时，这非常有用。通过将一个属性的完整定义分解为多个 packet，我们可以更快地将相关数据输入 Cesium 中，从而最大限度地减少用户在 Cesium 开始渲染场景之前必须等待的时间。

当客户端收到 CZML packet 时，它会遍历 packet 中包含的每个属性。对于每个属性，它将遍历定义属性的每个时间区间。对于每个时间区间，它确定是否已为属性定义了指定的时间区间。如果已经定义了，则更新现有时间区间；否则，将创建一个新的。

更新现有时间区间时，提供的任何子属性值都将替换现有值（如果有）。唯一的例外情况是，旧属性值和新属性值都包含带时间标记的采样。在这种情况下，样本将添加到该时间区间的样本列表中。

当新时间区间与原有时间区间重叠时，新时间区间优先，原时间区间被截断或完全删除。记住这一点很重要，当判断之后的时间区间需要新建还是更新原有区间时，会与被截断的时间区间进行比较。

单个 packet 中时间区间内的样本必须按时间来排序。然而，在 packet 之间，没有必要以任何特定顺序提供样本。然而，在流式传输非连续样本时，必须注意确保合理的插值。

## Availability 可用性

除了 `id` 属性之外，CZML packet 还有一个额外的特殊属性：`availability`。

```javascript
{
    "id": "PredatorUAV",
    "availability": "2012-04-30T12:00:00Z/14:00:00Z",
    // ...
}
```

`availability` 属性表示对象的数据何时可用。如果已知对象的数据在当前动画时间可用，但客户端尚未拥有该数据（可能是因为它将在稍后的数据包中到达），客户端可能会暂停，并在等待接收数据时显示类似 "Buffering..." 的消息。属性的值可以是指定单个时间区间的字符串，也可以是表示事件区间的字符串数组。

如果 Cesium packet 发生变化或发现不正确，则后到达的 Cesium packet 可以更新此可用性。例如，SGP4 传播程序可能会一直报告可用性，但随后传播程序会抛出异常，需要调整可用性。如果此可选属性不存在，则假定对象始终可用。可用性的范围是特定的 CZML 流，因此两个不同的流可以为单个对象列出不同的可用性。在单个流中，为对象声明的最后一个可用性是有效的可用性，并且忽略以前数据包中的任何可用性。如果某个对象在某个时间可用，客户端希望该对象至少有一个属性，并希望在该时间定义它需要的所有属性。如果对象没有任何属性，或者定义了所需的属性但未在动画时定义，则客户端会暂停动画并等待更多数据。

## Extending CZML 扩展 CZML

CZML 可以通过自定义属性进行扩展。为了尽量减少冲突，我们建议用户在自定义属性前面加上某种标识符。
